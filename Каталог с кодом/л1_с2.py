# -*- coding: utf-8 -*-
"""Л1 С2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n1RXj9Y2kPVLJjtIwAeXdJXJJoGk_BmO
"""

import matplotlib.pyplot as plt
import numpy as np

#Строим график
x = np.arange(-6,5)
y = x**3 + 2.5 * x**2 - 14*x - 7.5
plt.figure(1)
plt.plot(x,y,[-5,0],[3,0],'ro',linewidth=2)
plt.grid()
plt.show()

from scipy.optimize import bisect
# Объявление функции с левой частью уравнения
def my_fun(x):
    return x**3 + 2.5 * x**2 - 14*x - 7.5
# Вызов функций, решающих уравнение
x1 = bisect(my_fun,-6,-2)
x2 = bisect(my_fun,-2,0)
x3 = bisect(my_fun,0,4)
print("x1=",x1, "\nx2=",x2, "\nx3=",x3)
files.download('')

a = int(input('Введите 1е значение интервала: '))
b = int(input('Введите 2е значение интервала: '))
accuracy = 10**(-5)

def f(x):
    return x**3 + 2.5 * x**2 - 14*x - 7.5

def output(iteration, x, accuracy):
    print ('Итерация # {}'.format(iteration))
    print ('Приблизительное значение {}'.format(x))
    #print ('Error: {}'.format(accuracy))

def horde(a, b, accuracy):
    c = (a * f(b) - b * f(a)) / (f(b) - f(a))
    iteration = 1
    while True:
        output(iteration, c, abs(f(c)))
        if f(c) == 0:
            return c
        elif f(a) * f(c) < 0:
            b = c       
        elif f(b) * f(c) < 0:
            a = c
        c_prev, c = c, (a * f(b) - b * f(a)) / (f(b) - f(a))
        if abs(c_prev - c) < accuracy or abs(f(c)) < accuracy:
            break
        iteration += 1
        return c
horde(a, b, accuracy)

import matplotlib.pyplot as plt
import numpy as np
# Объявление функции, содержащей правую часть уравнения
def my_fun(I):
  E = 10
  r = 2
  return I - E/(10*math.sin(I/40)*math.e**(-0.1*I))
# Создание массивов координат точек графика
I = np.arange(1,2.5,0.01)
Y = my_fun(I)
# Построение графика
plt.figure(1)
plt.plot(I,Y)
plt.grid()